Funny Lemon Dove

high

# User can't get rewards if he exits early

## Summary
User can't get rewards if he exits early
## Vulnerability Detail
According to the sponsor, exiting early should stop the accumulation of rewards, however even if a user has accumulated rewards he will not be able to get them. 

Lets say that he has a single lock and exits early. In the `earlyExitById` function his `bal.lockedWithMultiplier` will become 0, and after he calls `getReward` his rewards will be updated with his `balance.lockedWithMultiplier` being 0. This will lead to `rewards[account][token]` becoming 0 as well.
## Impact
User will be unable to withdraw his accumulated rewards if he exits early.
## Code Snippet

https://github.com/sherlock-audit/2024-05-gamma-staking/blob/main/StakingV2/src/Lock.sol#L313-L343
https://github.com/sherlock-audit/2024-05-gamma-staking/blob/main/StakingV2/src/Lock.sol#L526-L529
https://github.com/sherlock-audit/2024-05-gamma-staking/blob/main/StakingV2/src/Lock.sol#L614-L629
https://github.com/sherlock-audit/2024-05-gamma-staking/blob/main/StakingV2/src/Lock.sol#L455-L462
https://github.com/sherlock-audit/2024-05-gamma-staking/blob/main/StakingV2/src/Lock.sol#L538-L559

```Solidity
function earlyExitById(uint256 lockId) external whenNotPaused {
        if (isEarlyExitDisabled) {
            revert EarlyExitDisabled();
        }
        _updateReward(msg.sender);

        LockedBalance memory lock = locklist.getLockById(msg.sender, lockId);

        if (lock.unlockTime != 0)
            revert InvalidLockId();
        uint256 coolDownSecs = calcRemainUnlockPeriod(lock);
        lock.unlockTime = block.timestamp + coolDownSecs;
        uint256 penaltyAmount = calcPenaltyAmount(lock);
        locklist.removeFromList(msg.sender, lockId);
        Balances storage bal = balances[msg.sender];
        lockedSupplyWithMultiplier -= lock.amount * lock.multiplier;
        lockedSupply -= lock.amount;
        bal.locked -= lock.amount;
        bal.lockedWithMultiplier -= lock.amount * lock.multiplier;

        _updateRewardDebt(msg.sender);

        if (lock.amount > penaltyAmount) {
            IERC20(stakingToken).safeTransfer(msg.sender, lock.amount - penaltyAmount);
            IERC20(stakingToken).safeTransfer(treasury, penaltyAmount);
            emit EarlyExitById(lockId, msg.sender, lock.amount - penaltyAmount, penaltyAmount);
        } else {
            IERC20(stakingToken).safeTransfer(treasury, lock.amount);
        emit EarlyExitById(lockId, msg.sender, 0, penaltyAmount);
        }
    }
```
```Solidity
function getReward(address[] memory _rewardTokens) public nonReentrant {
        _updateReward(msg.sender); // Updates any accrued rewards up to the current point for the caller.
        _getReward(msg.sender, _rewardTokens); // Calls the internal _getReward function to process the actual reward claim.
    }
```
```Solidity
function _updateReward(address account) internal {
        uint256 length = rewardTokens.length; // Determine the number of reward tokens.
        Balances storage bal = balances[account]; // Access the balance record for the user.

        for (uint256 i = 0; i < length; ) {
            address token = rewardTokens[i]; // Access each token.
            Reward memory rewardInfo = rewardData[token]; // Get the reward data for the token.

            rewards[account][token] += _earned(account, token); // Update the rewards for the user based on what has been earned so far.
            rewardDebt[account][token] = rewardInfo.cumulatedReward * bal.lockedWithMultiplier; // Update the reward debt based on the latest reward information.

            unchecked {
                i++;
            }
        }
    }
```
```Solidity
function _earned(
        address _user,
        address _rewardToken
    ) internal view returns (uint256 earnings) {
        Reward memory rewardInfo = rewardData[_rewardToken]; // Retrieves reward data for the specified token.
        Balances memory balance = balances[_user]; // Retrieves balance information for the user.
        earnings = rewardInfo.cumulatedReward * balance.lockedWithMultiplier - rewardDebt[_user][_rewardToken]; // Calculates earnings by considering the accumulated reward and the reward debt.
    }
```
```Solidity
function _getReward(
        address _user,
        address[] memory _rewardTokens
    ) internal whenNotPaused {
        uint256 length = _rewardTokens.length; // Get the number of reward tokens to process.
        for (uint256 i = 0; i < length; ) {
            address token = _rewardTokens[i]; // Get the current token address.

            uint256 reward = rewards[_user][token]; // Retrieve the amount of reward due for the user and the token.
            if (reward > 0) {
                rewards[_user][token] = 0; // Reset the reward to zero after claiming.
                rewardData[token].balance -= reward / 1e36; // Deduct the reward from the stored balance, adjusting for decimals.

                IERC20(token).safeTransfer(_user, reward / 1e36); // Transfer the reward to the user.
                rewardPaid[_user][token] += reward / 1e36; // Update the total reward paid to the user for this token.
                emit RewardPaid(_user, token, reward / 1e36); // Emit an event documenting the reward payment.
            }
            unchecked {
                i++;
            }
        }
    }
```

## Tool used

Manual Review

## Recommendation
One fix would be to just send the rewards with the staking token in the `earlyExitById` function.