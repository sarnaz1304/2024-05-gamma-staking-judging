Sweet Tweed Moose

high

# staker is able to drain contract`s rewards

## Summary
staker is able to drain contract`s rewards, because of missing logic in `getReward` function by calling it several times

## Vulnerability Detail
The issue comes from that every time `getReward` function gets called there is a call for `_updateRewards` which resets `rewards[account][token]`  value letting a staker call this function several times as long as there is reward tokens in the contract
```solidity
    function getReward(address[] memory _rewardTokens) public nonReentrant {
        _updateReward(msg.sender); // Updates any accrued rewards up to the current point for the caller.
        _getReward(msg.sender, _rewardTokens); // Calls the internal _getReward function to process the actual reward claim.
    }
```
```solidity
function _getReward(
        address _user,
        address[] memory _rewardTokens
    ) internal whenNotPaused {
        uint256 length = _rewardTokens.length; // Get the number of reward tokens to process.
        for (uint256 i = 0; i < length; ) {
            address token = _rewardTokens[i]; // Get the current token address.

            uint256 reward = rewards[_user][token]; // Retrieve the amount of reward due for the user and the token.
            if (reward > 0) {
                rewards[_user][token] = 0; // Reset the reward to zero after claiming.
                rewardData[token].balance -= reward / 1e36; // Deduct the reward from the stored balance, adjusting for decimals.

                IERC20(token).safeTransfer(_user, reward / 1e36); // Transfer the reward to the user.
                rewardPaid[_user][token] += reward / 1e36; // Update the total reward paid to the user for this token.
                emit RewardPaid(_user, token, reward / 1e36); // Emit an event documenting the reward payment.
            }
            unchecked {
                i++;
            }
        }
    } 
```
in `_getReward` function tries to set `rewards[_user][token]` value to 0, but this is invalid because every call to `getRewards` function calls `updateRewards` which sets it back to the old value giving user a permission to drain the contract 
```solidity
function _updateReward(address account) internal {
        uint256 length = rewardTokens.length; // Determine the number of reward tokens.
        Balances storage bal = balances[account]; // Access the balance record for the user.

        for (uint256 i = 0; i < length; ) {
            address token = rewardTokens[i]; // Access each token.
            Reward memory rewardInfo = rewardData[token]; // Get the reward data for the token.

            rewards[account][token] += _earned(account, token); // Update the rewards for the user based on what has been earned so far.
            rewardDebt[account][token] = rewardInfo.cumulatedReward * bal.lockedWithMultiplier; // Update the reward debt based on the latest reward information.

            unchecked {
                i++;
            }
        }
    }
```
```solidity 
function _earned(
        address _user,
        address _rewardToken
    ) internal view returns (uint256 earnings) {
        Reward memory rewardInfo = rewardData[_rewardToken]; // Retrieves reward data for the specified token.
        Balances memory balance = balances[_user]; // Retrieves balance information for the user.
        
        earnings = rewardInfo.cumulatedReward * balance.lockedWithMultiplier - rewardDebt[_user][_rewardToken]; // Calculates earnings by considering the accumulated reward and the reward debt.
    }
```
Staker can call `getReward` function several times and drain the contract`s reward tokens

## Impact
High, protocol losses funds

## Code Snippet
https://github.com/sherlock-audit/2024-05-gamma-staking/blob/main/StakingV2/src/Lock.sol#L526

## Tool used
Manual Review

## Recommendation
Add additional check to rewards that should be given